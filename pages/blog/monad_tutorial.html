<!--
title: Monad Tutorial
date_published: 2025-06-27
tags: functional_programming
-->
<article>
  <p>
    A couple of years after graduating college, I discovered functional programming.
    I started with <abbr title="Language INtegrated Query">LINQ</abbr> and immutability in .NET, but I quickly found <a href="https://en.wikipedia.org/wiki/Haskell" target="_blank">Haskell</a>.
    I explored the <abbr title="Functional Programming">FP</abbr> rabbit hole for a few years before eventually deciding that while there are benefits to programming in this paradigm, there are also some pretty big downsides.
  </p>

  <p>
    Today, I want to focus on one of the most (in)famous abstractions provided by FP: the <code>Monad</code>.
    <a href="https://wiki.haskell.org/Monad_tutorials_timeline" target="_blank">Many have tried to explain monads</a> in an easy to understand way.
    Many have failed and few have succeeded.
    In this article, I will try my hand at explaining them.
    I will provide code examples in Haskell and C#.
  </p>

  <h3>Prerequisites</h3>
  <p>
    In this tutorial, I will assume you have some basic programming experience and a <a href="https://wiki.haskell.org/Learn_Haskell_in_10_minutes" target="_blank">basic understanding of Haskell and it's syntax</a>.
    You should understand Haskell type signatures and function application syntax.
    You should also understand basic Haskell typeclasses like <code>Eq</code> and <code>Monoid</code>.
    You should be able to understand the C# examples if you've used any other object-oriented C-like language.
  </p>

  <h3>Motivation</h3>
  <p>
    The first question to answer is "<i>Why Monads?</i>".
    Monads were <a href="https://dl.acm.org/doi/pdf/10.1145/158511.158524" target="_blank">first borrowed</a> from an area of math called
    <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/" target="_blank">Category Theory</a> to enable <abbr title="Input/Output">I/O</abbr> in Haskell in a
    <a href="https://en.wikipedia.org/wiki/Referential_transparency" target="_blank">referentially transparent</a> way.
    Since there are no side effects in Haskell, the monad abstraction is used to build up a <i>sequence</i> of I/O operations without executing them until returning them from the <code>main</code> function.
    The key thing here is <i>sequence</i>.
    <b>Something is a Monad when you are able to string sequences of that thing together.</b>
    So, the <code>IO</code> type in Haskell <i>is</i> a monad because of the ability to string a sequence of values of type <code>IO a</code> together.
  </p>

  <p>
    Before I explain Monads, I need to explain two other abstractions that Monads are built upon: <code>Functors</code> and <code>Applicative Functors</code>
    This is necessary because every <code>Monad</code> is also an <code>Applicative Functor</code> and a <code>Functor</code>, and every <code>Applicative Functor</code> is a <code>Functor</code>.
    Each abstraction builds on the next.
  </p>

  <p>Functor ‚Üí Applicative Functor ‚Üí Monad</p>

  <p>Also, Functors are much easier to understand.</p>

  <h3>Functors</h3>
  <p>
    <b>Something is a Functor when you are able to <i>map</i> a function over it.</b>
  </p>

  <p>
    Some common examples are lists of items, an optional item, and I/O values, as mentioned above.
    A good way to conceptualize a functor is as a container.
    However, you should know that this is a simplification.
    If you want to modify the items in the container without taking them out of the container, you can use the Functor's map function.
    This function takes two parameters: the container containing items of type <code>a</code> and a function which converts the items inside the container from type <code>a</code> to type <code>b</code>.
    The function returns a new container containing items of type <code>b</code>.
  </p>

  <p>
    In Haskell this mapping function is called <code>fmap</code>. Here is the formal definition of the <code>Functor</code> typeclass in Haskell.
  </p>

  <code class="language-haskell">
-- Simplified typeclass definition
class Functor f where
  fmap :: (a -> b) -> f a -> f b -- infix operator is <&>

-- Functor laws
-- fmap id == id
-- fmap (f . g) == fmap f . fmap g -- '.' is function composition: (f . g) x == f (g x)
  </code>

  <p>
    The above is a simplified definition.
    <a href="https://hackage.haskell.org/package/ghc-internal-9.1201.0/docs/src/GHC.Internal.Base.html#Functor" target="_blank">Here</a> is the actual definition, if you're interested.
  </p>

  <p>
    To let the Haskell compiler to know that a type is a <code>Functor</code>, you must implement the <code>fmap</code> function.
    You will also need to ensure that the Functor laws hold true for your implementation.
    The <i>laws</i> of a typeclass are just equations that are part of the mathematical definition of a typeclass.
    There is no way to enforce laws at compile time in Haskell, so be careful.
  </p>

  <p>
    So, for the three common examples mentioned above, you would need to implement <code>fmap</code> for each, respectively.
  </p>

  <code class="language-haskell">
-- [optional item]
instance Functor Maybe where
  fmap :: (a -> b) -> Maybe a -> Maybe b
  fmap = undefined

-- [list of items]
-- List has a special syntax
-- This is what the instance would look like if the syntax were consistent
--instance Functor List where
--  fmap :: (a -> b) -> List a -> List b
--  fmap = undefined

-- Actual List instance
instance Functor [] where
  fmap :: (a -> b) -> [a] -> [b]
  fmap = undefined

-- [I/O values]
instance Functor IO where
  fmap :: (a -> b) -> IO a -> IO b
  fmap = undefined
  </code>

  <p>
    I have left the instances unimplemented as exercise (for <code>Maybe</code> and <code>List</code>, at least) for the reader.
    Here are the implementations for
    <a href="https://hackage.haskell.org/package/ghc-internal-9.1201.0/docs/src/GHC.Internal.Base.html#line-1556" target="_blank">Maybe</a>,
    <a href="https://hackage.haskell.org/package/ghc-internal-9.1201.0/docs/src/GHC.Internal.Base.html#line-1733" target="_blank">List</a>,
    and <a href="https://hackage.haskell.org/package/ghc-internal-9.1201.0/docs/src/GHC.Internal.Base.html#line-2295" target="_blank">IO</a>.
    Now that the compiler knows that each of these types is a Functor, you can use <code>fmap</code> to apply a function to each item in each container.
  </p>

  <code class="language-haskell">
-- The function to apply
doubleValue :: Int -> Int
doubleValue x = x*2
------------------------------------
-- Maybe
optional :: Maybe Int
optional = Just 5

fmap doubleValue optional -- Just 10
------------------------------------
-- List
list :: [Int]
list = [1, 2, 3]

fmap doubleValue list -- [2, 4, 6]
------------------------------------
-- IO
userVal :: IO Int
userVal = readInt

fmap doubleValue userVal -- doubles the value the user entered
  </code>

  <p>
    The power of Haskell shines with what I will demonstrate next.
    Since Haskell understands that each of the types has the same <code>Functor</code> structure, you can now write functions that operate on any <code>Functor</code>!
  </p>

  <code class="language-haskell">
doubleAll :: Functor f => f Int -> f Int
doubleAll = fmap doubleValue

doubleAll optional -- Just 10
doubleAll list -- [2, 4, 6]
doubleAll userVal -- doubles the value the user entered
  </code>

  <p>
    You can do this in Haskell because of it's support for <a href="https://serokell.io/blog/kinds-and-hkts-in-haskell" target="_blank">Higher-Kinded Types</a>.
    Functors are higher-kinded types, and so are Applicative Functors and Monads.
    While you can implement the mapping function in C# where it is called Select, you aren't able to write functions that operate on any Functor because of a lack of support for <abbr title="Higher-Kinded Types">HKTs</abbr>.
    The <a href="https://github.com/louthy/language-ext" target="_blank">language-ext</a> library attempts to do this in C#, but it is a lot more involved, and I don't recommend it.
    Here's what a Functor looks like in C# using extension methods.
  </p>

  <code class="language-csharp">
static class FunctorExtensions {
    public static SomeFunctor<B> Select<A, B>(this SomeFunctor<A> source, Func<A, B> f) {
        // implementation
    }

    // Functor laws
    // items.Select(static x => x) == (static x => x)
    // items.Select(static x => g(f(x))) == items.Select(static x => g(x)).Select(static x => f(x))


    // Examples:
    public static IEnumerable<B> Select<A, B>(this IEnumerable<A> source, Func<A, B> f) {}
    public static B? Select<A, B>(this A? source, Func<A, B> f) {}
    public static Task<B> Select<A, B>(this Task<A> source, Func<A, B> f) {}

    // Usage:
    static int DoubleValue(int x) => x*2;

    int? optional = 5;
    optional.Select(DoubleValue); // (int?)10

    IEnumerable<int> items = [1, 2, 3];
    items.Select(DoubleValue); // [2, 4, 6]

    Task<int> taskValue = Get5FromDBAsync();
    await taskValue.Select(DoubleValue); // 10
}
  </code>

  <p>
    I have, again, left the instances unimplemented as exercise for the reader.
  </p>

  <p>
    C#'s <code>Task</code> type behaves similarly to Haskell's <code>IO</code> type.
    This will become relevant later when I finally explain Monads.
  </p>

  <h3>Applicative Functors and Monads</h3>
  <p>
    Now that you understand Functors, you are one step away from understanding both Applicative Functors and Monads.
    These two concepts are related, so I want to talk about the similarities and differences.
  </p>

  <p>
    As I said before, Monads are used for building sequences of operations.
    Formally, this means that each operation has a dependency on the previous.
    In the same way, Applicative Functors are useful for building groups of operations that aren't sequential.
    In other words, each operation doesn't have a dependency on the others.
  </p>

  <p>
    Before showing you the definition of Applicative Functors and Monads, I will show you their usage using Haskell's special <code>do</code> syntax.
    In Haskell, <code>do</code> notation is special syntax that makes working with Applicative Functors and Monads more readable. 
    It allows you to write sequences of operations in a more imperative style, even though under the hood it's translated to normal function calls.
    The left arrow <code>&lt;-</code> extracts a value from its context, and <code>pure</code> wraps a value in a context.
    Here are examples showing both Applicative Functors and Monads:
  </p>

  <code class="language-haskell">
-- Applicative Functor
result :: Maybe Int
result = do
  a <- Just 2
  b <- Just 3 -- no dependency
  pure (a+b)

-- result == Just 5

-- Monad
safeDiv :: Int -> Int -> Maybe Int
safeDiv _ 0 = Nothing
safeDiv x y = Just (div x y)

result :: Maybe Int
result = do
  a <- Just 100
  b <- safeDiv a 5 -- this line depends on the previous
  pure (b+1)

-- result == Just 21
  </code>

  <p>
    In the first example, each operation is independent, therefore it is only necessary that the <code>Maybe</code> type has the <code>Applicative Functor</code> instance implemented for it.
    In the second example, the second operation depends on the first, therefore it is necessary that the <code>Maybe</code> type has the <code>Monad</code> instance implemented for it.
  </p>

  <p>
    Previously, I said Functors can be thought of as containers of values.
    This is true of Applicative Functors and Monads, since they are both Functors.
    However, it is better to view them as values with some associated context.
    To build up the operations, you need to define a way to combine the contexts.
    You do this in Haskell by implementing the <code>Applicative</code> and <code>Monad</code> typeclasses.
  </p>

  <code class="language-haskell">
class Functor m => Applicative m where
  pure :: a -> m a
  ap :: m (a -> b) -> m a -> m b -- infix operator is <*>

-- Applicative laws
-- ap (pure id) x == x                            -- Identity
-- ap (pure f) (pure x) == pure (f x)             -- Homomorphism
-- ap (ap (ap (pure (.)) u) v) w  = ap u (ap v w) -- Composition
-- ap mf (pure v) == ap (pure (\f -> f v)) mf     -- Interchange

class Applicative m => Monad m where
  bind :: (a -> m b) -> m a -> m b -- infix operator is >>=

-- Monad laws
-- bind h (pure a) == h a -- Left identity
-- bind pure m == m       -- Right identity
-- (bind h (bind g m)) == bind (\x -> bind h (g x)) m -- Associativity
  </code>

  <p>
    I have taken liberties to simplify these definitions.
    Here are the actual definitions for <a href="https://hackage.haskell.org/package/ghc-internal-9.1201.0/docs/src/GHC.Internal.Base.html#Applicative" target="_blank">Applicative</a> and <a href="https://hackage.haskell.org/package/ghc-internal-9.1201.0/docs/src/GHC.Internal.Base.html#Monad" target="_blank">Monad</a>.
  </p>

  <p>
    I will now implement all three typeclasses for <code>Maybe</code>, so you can see an example of how to combine the contexts.
  </p>

  <code class="language-haskell">
instance Functor Maybe where
  fmap _ Nothing = Nothing
  fmap f (Just x) = Just (f x)

instance Applicative Maybe where
  pure x = Just x

  ap _ Nothing = Nothing
  ap Nothing _ = Nothing
  ap (Just f) (Just x) = Just (f x)

instance Monad Maybe where
  bind _ Nothing = Nothing
  bind f (Just x) = f x
  </code>

  <p>
    Once again, here are the actual implementations of the <code>Maybe</code> <a href="https://hackage.haskell.org/package/ghc-internal-9.1201.0/docs/src/GHC.Internal.Base.html#line-1556" target="_blank">instances</a> of <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code>.
  </p>

  <p>
    For the <code>Maybe</code> type, the context is presence or absence of a value.
    For the <code>IO</code> type, the context is the side effects or the interactions with the external world.
    There are many types that are Monads, and each one has a different context.
  </p>

  <table>
    <thead>
      <tr><th>Type</th><th>Context</th></tr>
    </thead>

    <tbody>
      <tr><td>Identity</td><td>None</td></tr>
      <tr><td>Maybe</td><td>Presence/Absence of a value</td></tr>
      <tr><td>IO</td><td>Input/Output</td></tr>
      <tr><td>Reader</td><td>Configuration</td></tr>
      <tr><td>Writer</td><td>List of strings</td></tr>
      <tr><td>State</td><td>A mutable value</td></tr>
      <tr><td>RWS</td><td>combination of Reader, Writer, and State</td></tr>
      <tr><td>Except</td><td>Errors</td></tr>
      <tr><td>Parser</td><td>Position and state of parser</td></tr>
    </tbody>
  </table>

  <p>
    Here is the implementation of the three typeclasses for <code>Nullable&lt;T&gt;</code>, C#'s equivalent of <code>Maybe a</code>.
    Note that the C# code isn't perfectly analogous to Haskell.
  </p>

  <code class="language-csharp">
static class NullableInstances {
    public static B? Select<A, B>(this A? source, Func<A, B> selector)
      where A : struct
      where B : struct =>
        source.HasValue
            ? new B?(selector(source.Value))
            : null;

    public static B? SelectMany<A, B>(this A? source, Func<A, B?> selector)
      where A : struct
      where B : struct =>
        source.HasValue
            ? selector(source.Value)
            : null;

    public static C? SelectMany<A, B, C>(this A? source, Func<A, B?> collectionSelector, Func<A, B, C> resultSelector)
      where A : struct
      where B : struct
      where C : struct {
        if (source.HasValue) {
            var collection = collectionSelector(source.Value);
            if (collection.HasValue) {
                return resultSelector(source.Value, collection.Value);
            }
        }
        return null;
    }
}
  </code>

  <p>
    The <code>Select</code> method enables <code>Functor</code> like behavior and the two <code>SelectMany</code> overloads enable <code>Applicative</code> and <code>Monad</code> like behavior.
    C# actually has two special syntaxes for Monads.
    The first, <a href="https://learn.microsoft.com/en-us/dotnet/csharp/linq/" target="_blank">LINQ query syntax</a>, is similar to Haskell's <code>do</code> syntax:
  </p>

  <code class="language-csharp">
// Applicative Functor
int? result =
    from a in new int?(2)
    from b in new int?(3) // no dependency
    select a + b;

// int? result == 5

// Monad
static int? safeDiv(int x, int y) =>
    y == 0 ? null : x / y;

//result :: Maybe Int
int? result =
    from a in new int?(100)
    from b in safeDiv(a, 5) // this line depends on the previous
    select b + 1;

// int? result == 21
  </code>

  <p>
    And here is <a href="https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/" target="_blank">async/await syntax</a> for monadic behavior for the <code>Task</code> and <code>ValueTask</code> types:
  </p>

  <code class="language-csharp">
// Applicative Functor
int a = await Get2FromDBAsync();
int b = await Get3FromDBAsync();
int result = a + b;

// int result == 5

// Monad
// Simulating a lookup over the network
static async Task<int> LookupAsync(int x) => await Task.FromResult(x * 2);

//result :: Maybe Int
int a = await Get10FromDBAsync();
int b = await LookupAsync(a); // this line depends on the previous
int result = b + 1;

// int result == 21
  </code>

  <p>
    <code>Task</code> and async/await are used for asynchronous I/O in C#.
    I hope you get the idea from these simplified examples.
  </p>

  <h3>Practical application</h3>
  <p>
    And that's pretty much it for an introduction to Monads.
    Now I want to give my opinion on when to use what you've learned from this article in practice.
    First, Functors are very useful and fairly ubiquitous.
    Mapping over a sequence of values is a common operation in nearly every programming language, especially the ones that have generics.
    Basically, anytime I have a class with a type variable in C#, I implement the <code>Select</code> method because it's easy to implement and comes in handy frequently.
    In Haskell, it's even easier to implement <code>fmap</code> because if there is only one option, you can use <code>deriving Functor</code> to automatically generate a Functor instance.
  </p>

  <p>
    Monads and Applicative Functors, on the other hand, usually just aren't worth the trouble.
    In C#, isolated uses from time to time could be useful.
    Creating your own Monad isn't nearly as useful in C# because of the lack of HKT.
    When you create your own Monad in Haskell, you get lots of functions that automatically work with your type.
    You have to implement each one yourself in C#.
    <code>Task</code> and <code>async/await</code> are becoming more common in C#, and it's useful to know about their monadic structure.
    As you may have noticed, Monads also have a viral quality to them, so once you start using them, they start spreading all over your program via the type system.
    This makes them somewhat of a commitment once you start using them.
    That's pretty much the extent of my Monad use in C#.
    I think this would apply to similar statically typed, object-oriented languages.
    I should also mention Rust's error handling with it's <code>Option</code> and <code>Result</code> types is monadic.
  </p>

  <p>
    In Haskell, you are forced to do I/O inside the <code>IO</code> monad, at least at the top level of your program.
    However, in larger programs, it is generally frowned upon to have all of the different types of I/O directly under <code>IO</code>.
    It is frowned upon because you generally want static type safety, especially if you are using Haskell.
    Throwing everything into <code>IO</code> is kind of like having dynamic typing for side effects.
    Imagine you have a function with this type signature: <code>getData :: String -&gt; IO ResultType</code>.
    Where does it get the data from?
    The console, a file, a SQL database query, an HTTP request?
  </p>

  <p>
    There are many solutions to this problem in Haskell, and, in my opinion, none of them are good enough.
    I haven't really followed Haskell for about 6 years, though, so take what I have to say on this topic with a grain of salt.
    Here is a table containing my view of the state of all of the solutions for dealing with effects in Haskell.
  </p>

  <table>
    <thead>
      <tr>
        <th>Technique</th><th>Description</th><th>Libraries</th>
        <th><abbr title="Performance">Perf.</abbr></th>
        <th><abbr title="Boilerplate">BP</abbr></th>
        <th><abbr title="Ergonomics">Ergo.</abbr></th>
        <th><abbr title="Maturity">Mat.</abbr></th>
      </tr>
    </thead>

    <tbody>
      <tr>
        <td>IO</td><td>Everything in IO</td>
        <td><a href="https://hackage.haskell.org/package/ghc-prim" target="_blank">ghc-prim</a></td>
        <td style="text-align:center">ü•á</td><td style="text-align:center">ü•á</td><td style="text-align:center">‚ùå</td><td style="text-align:center">ü•á</td>
      </tr>
      <tr>
        <td><a href="https://www.williamyaoh.com/posts/2023-06-10-monad-transformers-101.html" target="_blank">Transformers stack</a></td>
        <td>Build up a stack and write polymorphic functions</td>
        <td><a href="https://hackage.haskell.org/package/transformers" target="_blank">transformers</a> + <a href="https://hackage.haskell.org/package/mtl" target="_blank">mtl</a></td>
        <td style="text-align:center">ü•â</td><td style="text-align:center">ü•á</td><td style="text-align:center">ü•à</td><td style="text-align:center">ü•á</td>
      </tr>
      <tr>
        <td><a href="https://serokell.io/blog/introduction-to-free-monads" target="_blank">Free Monads</a></td>
        <td>Build abstract syntax tree of effects</td>
        <td><a href="https://hackage.haskell.org/package/free" target="_blank">free</a></td>
        <td style="text-align:center">ü•à</td><td style="text-align:center">ü•â</td><td style="text-align:center">ü•à</td><td style="text-align:center">ü•á</td>
      </tr>
      <tr>
        <td><a href="https://academy.fpblock.com/blog/2017/06/readert-design-pattern/">ReaderT Env IO</a></td>
        <td>Pass environment with effects through program</td>
        <td><a href="https://hackage-content.haskell.org/package/transformers-0.6.2.0/docs/Control-Monad-Trans-Reader.html" target="_blank">ReaderT</a> from <a href="https://hackage.haskell.org/package/transformers" target="_blank">transformers</a></td>
        <td style="text-align:center">ü•á</td><td style="text-align:center">ü•à</td><td style="text-align:center">ü•à</td><td style="text-align:center">ü•à</td>
      </tr>
      <tr>
        <td><a href="https://hackage-content.haskell.org/package/effectful-core-2.6.0.0/docs/Effectful-Dispatch-Dynamic.html" target="_blank">Effect systems</a></td>
        <td>Define effects and corresponding handlers</td>
        <td>
          <a href="https://hackage.haskell.org/package/extensible-effects" target="_blank">extensible-effects</a>,
          <a href="https://hackage.haskell.org/package/freer-simple" target="_blank">freer-simple</a>,
          <a href="https://hackage.haskell.org/package/fused-effects" target="_blank">fused-effects</a>,
          <a href="https://hackage.haskell.org/package/polysemy" target="_blank">polysemy</a>,
          <a href="https://hackage.haskell.org/package/effectful" target="_blank">effectful</a>
        </td>
        <td style="text-align:center">ü•à</td><td style="text-align:center">ü•à</td><td style="text-align:center">ü•á</td><td style="text-align:center">‚ùå</td>
      </tr>
      <tr>
        <td><a href="https://github.com/zio/zio" target="_blank">Scala ZIO</a> like</td><td>FP ecosystem in Scala, rio was closest in Haskell</td><td><a href="https://hackage.haskell.org/package/rio" target="_blank">rio</a></td>
        <td style="text-align:center">ü•á</td><td style="text-align:center">ü•á</td><td style="text-align:center">ü•á</td><td style="text-align:center">‚ùå</td>
      </tr>
    </tbody>
  </table>

  <p>
    As you can see, there are pros and cons to each solution and no definitively superior choice.
    In my research for this article, I came across a new effect system library called <a href="https://github.com/haskell-effectful/effectful">effectful</a>.
    It seems to have the most activity surrounding it and seems to be the preferred solution at the moment.
  </p>

  <h3>Conclusion</h3>
  <p>
    In conclusion, I don't think Monads are a great solution to the problem of I/O in pure functional programming, but it is good to understand them, since they pop up here and there in more popular programming languages.
    Functional programming brings some good ideas to the table, but it isn't a pure win that some make it out to be.
    Greater abstraction capabilities come at the cost of low-level understanding and, as currently implemented, runtime and compiler performance.
    Ironically, it can also become a distraction from the task at hand.
    Maybe, in the future, we will get to a solution that makes this way of programming much better than the alternatives, but we sadly aren't there yet.
  </p>

  <p>My advice is to focus on building something cool no matter the tool, language, or paradigm and to not get too caught up in the hype.</p>
</article>
