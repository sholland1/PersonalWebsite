<!--
title: Monad Tutorial
tags: functional_programming
-->
<!--
TODO:
  [ ] talk a little more about pros and cons of FP
  [ ] add more links
  [ ] improve table formatting
  [ ] add more info about effect systems
  [ ] make sure Haskell examples compile
  [ ] disclose all simplifications and add links to actual code
-->
<article>
  <p>
    A couple of years after graduating college, I discovered functional programming.
    I started with <abbr title="Language INtegrated Query">LINQ</abbr> in .NET, but I quickly found Haskell.
    I explored the <abbr title="Functional Programming">FP</abbr> rabbit hole for a few years before eventually deciding that while there are benefits to programming in this paradigm, there are also some pretty big downsides.
  </p>

  <p>
    I don't want to dwell on this pros and cons of FP for too long.
    A big promise of FP is that it enables greater abstraction capabilities which allow the programmer to focus on the problem rather than implementation details.
    The problem with this, in my opinion, is that it can sometimes inhibit understanding and reduce performance.
    It can also become a distraction.
  </p>

  <p>
    In this tutorial, I will assume you have some basic programming experience and a basic understanding of Haskell and it's syntax.
    You should understand Haskell type signatures and function application syntax.
    You should also understand basic Haskell typeclasses like <code>Eq</code> and <code>Monoid</code>.
    You should be able to understand the C# examples if you've used any other object-oriented C-like language.
  </p>

  <p>
    One of the most (in)famous abstractions provided by FP is the <code>Monad</code>.
    Many have tried to explain monads in an easy to understand way.
    Many have failed and few have succeeded.
    In this article, I will try my hand at explaining them.
    I will provide code examples in Haskell and C#.
  </p>

  <h3>Motivation</h3>
  <p>
    The first question to answer is "<i>Why Monads?</i>".
    Monads were first borrowed from an area of math called Category Theory to enable <abbr title="Input/Output">I/O</abbr> in Haskell in a referentially transparent way.
    Since there are no side effects in Haskell, the monad abstraction is used to build up a <i>sequence</i> of I/O operations without executing them until returning them from the <code>main</code> function.
    The key thing here is <i>sequence</i>.
    <b>Something is a Monad when you are able to string sequences of that thing together.</b>
    So, the <code>IO</code> type in Haskell <i>is</i> a monad because of the ability to string a sequence of values of type <code>IO</code> together.
  </p>

  <p>
    Before I explain Monads, I need to explain two other abstractions that Monads are built upon: <code>Functors</code> and <code>Applicative Functors</code>
    This is necessary because every <code>Monad</code> is also an <code>Applicative Functor</code> and a <code>Functor</code>, and every <code>Applicative Functor</code> is a <code>Functor</code>.
    Each abstraction builds on the next.
    Functor -&gt; Applicative Functor -&gt; Monad
    Also, Functors are much easier to understand.
  </p>

  <h3>Functors</h3>
  <p>
    <b>Something is a Functor when you are able to map a function over it.</b>

    Some common examples are lists of items, an optional item, and I/O values, as mentioned above.
    A good way to conceptualize a functor is as a container, however, you should know that this is a simplification.
    If you want to modify the items in the container without taking them out of the container, you can use the Functor's map function.
    This function takes two parameters, the container containing items of type <code>a</code> and a function which converts the items inside the container from type <code>a</code> to type <code>b</code>.
    The function returns a new container containing items of type <code>b</code>.

    In Haskell this mapping function is called <code>fmap</code>. Here is the formal definition of a <code>Functor</code> in Haskell.
  </p>

  <code class="language-haskell">
-- Simplified typeclass definition
class Functor f where
  fmap :: (a -> b) -> f a -> f b -- infix operator is <&>

-- Functor laws
-- fmap id == id
-- fmap (f . g) == fmap f . fmap g -- '.' is function composition: (f . g) x == f (g x)
  </code>

  <p>
    To let the Haskell compiler to know that a type is a <code>Functor</code>, you have to implement the <code>fmap</code> function.
    You will also need to ensure that Functor laws are hold true for your implementation.
    There is no way to enforce this in Haskell, so be careful.
    So, for the three common examples mentioned above, you would need to implement <code>fmap</code> for each, respectively.
  </p>

  <code class="language-haskell">
-- [optional item]
instance Functor Maybe where
  fmap :: (a -> b) -> Maybe a -> Maybe b
  fmap = undefined

-- [list of items]
-- List has a special syntax
-- This is what the instance would look like if the syntax were consistent
--instance Functor List where
--  fmap :: (a -> b) -> List a -> List b
--  fmap = undefined

-- Actual List instance
instance Functor [] where
  fmap :: (a -> b) -> [a] -> [b]
  fmap = undefined

-- [I/O values]
instance Functor IO where
  fmap :: (a -> b) -> IO a -> IO b
  fmap = undefined
  </code>

  <p>
    I have left the instances unimplemented as exercise for the reader.
    Now that the compiler knows that each of these types is a Functor, you can use <code>fmap</code> to apply a function to each item in each container.
  </p>

  <code class="language-haskell">
doubleValue :: Int -> Int
doubleValue x = x*2
------------------------------------
optional :: Maybe Int
optional = Just 5

fmap doubleValue optional -- Just 10
------------------------------------
list :: [Int]
list = [1, 2, 3]

fmap doubleValue list -- [2, 4, 6]
------------------------------------
userVal :: IO Int
userVal = readInt

fmap doubleValue userVal -- doubles the value the user entered
  </code>

  <p>
    The power of Haskell shines with what I will demonstrate next.
    Since Haskell understands that each of the types has the same <code>Functor</code> structure, you can now write functions that operate on any <code>Functor</code>!
  </p>

  <code class="language-haskell">
doubleAll :: Functor f => f Int -> f Int
doubleAll = fmap doubleValue

doubleAll optional -- Just 10
doubleAll list -- [2, 4, 6]
doubleAll userVal -- doubles the value the user entered
  </code>

  <p>
    You can do this in Haskell because of it's support for Higher-Kinded Types.
    Functors are higher-kinded types, and so are Applicative Functors and Monads.
    While you can implement the mapping function in C# where it is called Select, you aren't able to write functions that operate on any Functor because of a lack of support for <abbr title="Higher-Kinded Types">HKTs</abbr>.
    The <a href="https://github.com/louthy/language-ext" target="_blank">language-ext</a> library attempts to do this in C#, but it is a lot more involved, and I don't recommend it.
    Here's what a Functor looks like in C# using extension methods.
  </p>

  <code class="language-csharp">
static class FunctorExtensions {
    public static SomeFunctor<B> Select<A, B>(this SomeFunctor<A> source, Func<A, B> f) {
        // implementation
    }

    // Functor laws
    // items.Select(static x => x) == (static x => x)
    // items.Select(static x => g(f(x))) == items.Select(static x => g(x)).Select(static x => f(x))


    // Examples:
    public static IEnumerable<B> Select<A, B>(this IEnumerable<A> source, Func<A, B> f) {}
    public static B? Select<A, B>(this A? source, Func<A, B> f) {}
    public static Task<B> Select<A, B>(this Task<A> source, Func<A, B> f) {}

    // Usage:
    static int DoubleValue(int x) => x*2;

    int? optional = 5;
    optional.Select(DoubleValue); // (int?)10

    IEnumerable<int> items = [1, 2, 3];
    items.Select(DoubleValue); // [2, 4, 6]

    Task<int> taskValue = Task.FromResult(5);
    await taskValue.Select(DoubleValue); // 10
}
  </code>

  <p>
    C#'s <code>Task</code> type is similar to Haskell's <code>IO</code> type.
    This will become relevant later when I finally explain Monads.
  </p>

  <h3>Applicative Functors and Monads</h3>
  <p>
    Now that you understand Functors, you are one step away from understanding both Applicative Functors and Monads.
    These two concepts are related, so I want to talk about the similarities and differences.
  </p>

  <p>
    As I said before, Monads are used for building sequences of operations.
    Formally, this means that each operation has a dependency on the previous.
    In the same way, Applicative Functors are useful for building groups of operations that aren't sequential.
    In other words, each operation doesn't have a dependency on the others.
  </p>

  <p>
    Before showing you the definition of Applicative Functors and Monads, I will show you their usage using Haskell's special <code>do</code> syntax.
  </p>

  <code class="language-haskell">
-- Applicative Functor
result :: Maybe Int
result = do
  a <- Just 2
  b <- Just 3 -- no dependency
  pure (a+b)

-- result == Just 5

-- Monad
safeDiv :: Int -> Int -> Maybe Int
safeDiv _ 0 = Nothing
safeDiv x y = Just (x / y)

result :: Maybe Int
result = do
  a <- Just 100
  b <- safeDiv a 5 -- this line depends on the previous
  pure (b+1)

-- result == Just 21
  </code>

  <p>
    In the first example, each operation is independent, therefore it is only necessary that the <code>Maybe</code> type has the Applicative Functor instance implemented for it.
    In the second example, the second operation depends on the first, therefore it is necessary that the <code>Maybe</code> type has the Monad instance implemented for it.
  </p>

  <p>
    Previously, I said Functors can be thought of as containers of values.
    This is true of Applicative Functors and Monads, since they are both Functors.
    However, it is better to view them as values with some associated context.
    To build up the operations, you need to define a way to combine the contexts.
    You do this in Haskell by implementing the <code>Applicative</code> and <code>Monad</code> typeclasses, respectively.
  </p>

  <code class="language-haskell">
class Functor m => Applicative m
  pure :: a -> m a
  ap :: m (a -> b) -> m a -> m b -- infix operator is <*>

-- Applicative laws
-- ap (pure id) x == x                            -- Identity
-- ap (pure f) (pure x) == pure (f x)             -- Homomorphism
-- ap (ap (ap (pure (.)) u) v) w  = ap u (ap v w) -- Composition
-- ap mf (pure v) == ap (pure (\f -> f v)) mf     -- Interchange

class Applicative m => Monad m
  bind :: (a -> m b) -> m a -> m b -- infix operator is >>=

-- Monad laws
-- bind h (pure a) == h a -- Left identity
-- bind pure m == m       -- Right identity
-- (bind h (bind g m)) == bind (\x -> bind h (g x)) m -- Associativity
  </code>

  <p>
    I have taken liberties to simplify these definitions.
  </p>

  <p>
    I will implement all three typeclasses for <code>Maybe</code>, so you can see an example of how to combine the contexts.
  </p>

  <code class="language-haskell">
instance Functor Maybe where
  fmap _ Nothing = Nothing
  fmap f (Just x) = Just (f x)

instance Applicative Maybe where
  pure x = Just x

  ap _ Nothing = Nothing
  ap Nothing _ = Nothing
  ap (Just f) (Just x) = Just (f x)

instance Monad Maybe where
  bind _ Nothing = Nothing
  bind f (Just x) = Just (f x)
  </code>

  <p>
    For the <code>Maybe</code> type, the context is presence or absence of a value.
    For the <code>IO</code> type, the context is the side effects or the interactions with the external world.
    There are many types that are Monads, and each one has a different context.
  </p>

  <table>
    <thead>
      <tr><th>Type</th><th>Context</th></tr>
    </thead>

    <tbody>
      <tr><td>Identity</td><td>None</td></tr>
      <tr><td>Maybe</td><td>Presence/Absence</td></tr>
      <tr><td>IO</td><td>Input/Output</td></tr>
      <tr><td>Reader</td><td>Configuration</td></tr>
      <tr><td>Writer</td><td>List of strings</td></tr>
      <tr><td>State</td><td>A mutable value</td></tr>
      <tr><td>RWS</td><td>combination of<br>Reader, Writer, and State</td></tr>
      <tr><td>Except</td><td>Errors</td></tr>
      <tr><td>Parser</td><td>Position and state of parser</td></tr>
    </tbody>
  </table>

  <p>
    Here is the implementation of the three typeclasses for <code>Nullable&lt;T&gt;</code>, C#'s equivalent of <code>Maybe</code>.
  </p>

  <code class="language-csharp">
static class NullableInstances {
    public static B? Select<A, B>(this A? source, Func<A, B> selector)
      where A : struct
      where B : struct =>
        source.HasValue
            ? new B?(selector(source.Value))
            : null;

    public static B? SelectMany<A, B>(this A? source, Func<A, B?> selector)
      where A : struct
      where B : struct =>
        source.HasValue
            ? selector(source.Value)
            : null;

    public static C? SelectMany<A, B, C>(this A? source, Func<A, B?> collectionSelector, Func<A, B, C> resultSelector)
      where A : struct
      where B : struct
      where C : struct {
        if (source.HasValue) {
            var collection = collectionSelector(source.Value);
            if (collection.HasValue) {
                return resultSelector(source.Value, collection.Value);
            }
        }
        return null;
    }
}
  </code>

  <p>
    The <code>Select</code> method enables <code>Functor</code> like behavior and the two <code>SelectMany</code> overloads enable <code>Applicative</code> and <code>Monad</code> like behavior.
    C# actually has two special syntaxes for Monads.
    Here is LINQ query syntax:
  </p>

  <code class="language-csharp">
// Applicative Functor
int? result =
    from a in new int?(2)
    from b in new int?(3) // no dependency
    select a + b;

// int? result == 5

// Monad
static int? safeDiv(int x, int y) =>
    y == 0 ? null : x / y;

//result :: Maybe Int
int? result =
    from a in new int?(100)
    from b in safeDiv(a, 5) // this line depends on the previous
    select b + 1;

// int? result == 21
  </code>

  <p>
    And here is async/await syntax for monadic behavior for the <code>Task</code> and <code>ValueTask</code> types:
  </p>

  <code class="language-csharp">
// Applicative Functor
int a = await Task.FromResult(2);
int b = await Task.FromResult(3);
int result = a + b;

// int result == 5

// Monad
// Simulating a lookup over the network
static async Task<int> lookupAsync(int x) => await Task.FromResult(x * 2);

//result :: Maybe Int
int a = await Task.FromResult(10);
int b = await lookupAsync(a); // this line depends on the previous
int result = b + 1;

// int result == 21
  </code>

  <p>
    <code>Task</code> and async/await are used for asynchronous I/O in C#.
    I hope you get the idea from these simplified examples.
  </p>

  <h3>Conclusion</h3>
  <p>
    And that's pretty much it for an introduction to Monads.
    Now I want to give my opinion on when to use what you've learned from this article in practice.
    First, Functors are very useful and fairly ubiquitous.
    Mapping over a sequence of values in a common operation in nearly every programming language, especially the ones that have generics.
    Basically, anytime I have a class with a type variable in C#, I implement the Select method because it's easy to implement and comes in handy frequently.
    In Haskell, it's even easier to implement because if there is only one option, you can use <code>deriving Functor</code> to automatically generate a Functor instance.
  </p>

  <p>
    Monads and Applicative Functors, on the other hand, usually just aren't worth the trouble.
    In C#, isolated uses from time to time could be useful.
    Creating your own Monad isn't nearly as useful in C# because of the lack of HKT.
    When you create your own Monad in Haskell, you get lots of functions that automatically work with your type.
    You have to implement each one yourself in C#.
    <code>Task</code> and async/await are becoming more common in C#, and it's useful to know about their monadic structure.
    That's pretty much the extent of my Monad use in C#.
    I think this would apply to similar statically typed, object-oriented languages.
    I should also mention Rust's error handling with it's <code>Option</code> and <code>Result</code> types is monadic.
  </p>

  <p>
    In Haskell, you are forced to do I/O inside the IO monad, at least at the top level of your program.
    However, in larger programs, it is generally frowned upon to have all of the different types of I/O directly under IO.
    The reason it is frowned upon is because you generally want static type safety, especially if you are using Haskell.
    Throwing everything into <code>IO</code> is kind of like having dynamic typing for side effects.
    Imagine you have a function with this type signature: <code>getData :: String -&gt; IO ResultType</code>
    Where does it get the data from? console, file, database, http request
    There are many solutions to this problem in Haskell, and, in my opinion, none of them are good enough.
  </p>

  <table>
    <thead>
      <tr><th>Technique</th><th>Pros</th><th>Cons</th></tr>
      <tr><th>Technique</th><th>Description</th><th>Performance</th><th>Boilerplate</th><th>Ergonomics</th><th>Maturity</th></tr>
    </thead>

    <tbody>
      <tr><td>IO</td><td>🥇</td><td>🥇</td><td>❌</td><td>🥇</td></tr>
      <tr><td>transformers stack</td><td>🥉</td><td>🥇</td><td>🥈</td><td>🥇</td></tr>
      <tr><td>Free Monads</td><td>🥈</td><td>🥉</td><td>🥈</td><td>🥇</td></tr>
      <tr><td>effect systems</td><td>🥈</td><td>🥈</td><td>🥇</td><td>❌</td></tr>
      <tr><td>ReaderT Env IO</td><td>🥇</td><td>🥈</td><td>🥈</td><td>🥈</td></tr>
      <tr><td>Custom Monad</td><td>🥈</td><td>🥉</td><td>🥇</td><td>❌</td></tr>
      <tr><td>Scala ZIO like</td><td>🥇</td><td>🥇</td><td>🥇</td><td>❌</td></tr>
    </tbody>
  </table>

  <p>
    Finally, don't worry too much about monads.
    Focus on build something cool.
  </p>
</article>
